1|931|Minimum Falling Path Sum
https://leetcode.com/problems/minimum-falling-path-sum/
从最上面一行开始向下走，每次移动的时候最多只可以移动一列。
也就是说每次必须向下走一行，列可以不变、也可以向左右移动一列。
求到达最后一行的时候，最短的路径长度。
这个题和799香槟塔很像，都是二维空间求最大、最小的路径问题。
时间复杂度是O(MN)，空间复杂度是O(MN)。
数组中每个位置都要从上一层获得三个相邻列的最小值，
换句话说，每个位置都可以给下面三个相邻列传递最小值
即到每个位置的最短路径，就是当前数值加上到达上面那层的三个相邻列的最小值。
从i-1推出i
dp[i][j] = dp[i - 1][j];
dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
dp[i][j] = Math.min(dp[i][j], dp[i - 1][j + 1]);
dp[i][j] += A[i][j];

2|799|champagne-tower
https://leetcode.com/problems/champagne-tower/description/
第0排1个杯子，第1排2个杯子以此类推。
当某个杯子装满水，溢出的水均匀的向下一排的两边扩散。
给定n杯水，问第i行第j个杯子的满水情况。
从i推出i+1
double q = (tower[r][c] - 1.0 ) / 2.0 ;
tower[r+1][c] += q;
tower[r+1][c+1] += q;

3|053|Maximum Subarray
https://leetcode.com/problems/maximum-subarray/
For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
给定一串数字，要求求出连续的序列，使得这个连续序列的和最大.
当前和为sum,如果sum >0,那么加上当前元素，
否则sum=A[i],即抛弃负数的sum，重新开始。因为负数的sum是累赘

4|062|Unique Paths
https://leetcode.com/problems/unique-paths/
从m*n大小的图中左上方走到右下方，每次只能向右或者向下，问一共有多少种走法
设dp[i][j]为到坐标为（i,j）的方法数，则有dp[i][j]= dp[i-1][j]+dp[i][j-1]

5|063|Unique Paths II
https://leetcode.com/problems/unique-paths-ii/
dp[i][j] = dp[i-1][j] + dp[i][j-1] 的递推式依然成立
但是，一旦碰到了障碍物，那么这时的到这里的走法应该设为0，
因为机器人只能向下走或者向右走，所以到这个点就无法通过。
